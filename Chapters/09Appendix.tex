

\chapter*{A - Github repository}
\addcontentsline{toc}{chapter}{\protect\numberline{}A - Github repository} 

All code and latex-files used in this document are included in the Github repository linked below. Further explanations are given in the readme-file. 


\subsection*{Github repository link}
\begin{itemize}
    \item \url{https://github.com/ninasalvesen/thesis_latex_template}
\end{itemize}

\chapter*{B - Complete schema of indexed data}
{\label[appendix]{app-b}}
\addcontentsline{toc}{chapter}{\protect\numberline{}B - Complete schema of indexed data} 

\begin{lstlisting}[
caption={DQL schema of indexed data}
]
<Account.address>: string @index(hash) @upsert .
<Account.tags>: [string] @index(hash) .
<Account.is_contract>: bool @index(bool) .
<Block.base_fee_per_gas>: float .
<Block.datetime>: datetime @index(hour) .
<Block.difficulty>: string @index(hash) .
<Block.gas_limit>: int .
<Block.gas_used>: int @index(int) .
<Block.gas_price_avg>: float @index(float) .
<Block.gas_price_max>: float .
<Block.gas_price_min>: float .
<Block.gas_price_std_dev>: float .
<Block.number>: int @index(int) @upsert .
<Block.size>: int .
<Block.tx_count>: int .
<Block.miner>: uid @reverse .
<Block.withdrawals>: [uid] @reverse .
<ContractDeployment.block>: uid @reverse .
<ContractDeployment.contract>: uid @reverse .
<ContractDeployment.creation_bytecode>: string .
<ContractDeployment.creator>: uid @reverse .
<ContractDeployment.deployed_bytecode>: string .
<ContractDeployment.experimental>: bool .
<ContractDeployment.failed_deploy>: bool .
<ContractDeployment.skeleton>: uid @reverse .
<ContractDeployment.solc_version>: string .
<ContractDeployment.storage_address>: string .
<ContractDeployment.storage_protocol>: string .
<ContractDeployment.tx_hash>: string @index(hash) .
<ContractDeployment.name>: string @index(trigram) .
<ContractDeployment.verified_source>: bool @index(bool) .
<ContractDeployment.verified_source_code>: string @index(term) .
<ContractDestruction.balance_left>: string .
<ContractDestruction.block>: uid @reverse .
<ContractDestruction.contract>: uid @reverse .
<ContractDestruction.refound_address>: uid .
<ContractDestruction.failed>: bool @index(bool) .
<ContractDestruction.tx_hash>: string @index(hash) .
<Error.inputs>: string @index(trigram) .
<Error.name>: string @index(exact) .
<Error.signature>: string @index(hash) @upsert .
<Event.inputs>: string @index(trigram) .
<Event.name>: string @index(exact) .
<Event.signature>: string @index(hash) @upsert .
<Function.inputs>: string @index(trigram) .
<Function.name>: string @index(exact) .
<Function.bytes4>: string @index(hash) .
<Function.outputs>: string @index(trigram) .
<Function.signature>: string @index(hash) @upsert .
<Skeleton.bytecode>: string @index(hash) .
<Skeleton.erc20_compliancy>: int @index(int) .
<Skeleton.erc721_compliancy>: int @index(int) .
<Skeleton.errors>: [uid] @reverse .
<Skeleton.events>: [uid] @reverse .
<Skeleton.failed_decompilation>: bool .
<Skeleton.functions>: [uid] @reverse .
<Skeleton.similar_code>: [uid] .
<Skeleton.similar_interface>: [uid] .
<TokenTransfer.block>: uid @reverse .
<TokenTransfer.contract>: uid @reverse .
<TokenTransfer.from>: uid @reverse .
<TokenTransfer.to>: uid @reverse .
<TokenTransfer.tx>: uid .
<TokenTransfer.value>: string .
<TokenTransfer.token_id>: string @index(hash) .
<Transaction.block>: uid @reverse .
<Transaction.from>: uid @reverse .
<Transaction.gas>: int .
<Transaction.gas_price>: int .
<Transaction.hash>: string @index(hash) @upsert .
<Transaction.input>: string .
<Transaction.bytes4>: string @index(hash) .
<Transaction.max_fee_per_gas>: int .
<Transaction.max_priority_fee_per_gas>: int .
<Transaction.nonce>: int .
<Transaction.r>: string .
<Transaction.s>: string .
<Transaction.to>: uid @reverse .
<Transaction.v>: string .
<Transaction.value>: string .
<Log.contract>: uid @reverse .
<Log.block>: uid @reverse .
<Log.tx>: uid @reverse .
<Log.topic_0>: string @index(hash) .
<Log.topic_1>: string @index(hash) .
<Log.topic_2>: string @index(hash) .
<Log.topic_3>: string @index(hash) .
<Log.data>: string .
<Log.tx_index>: int .
<Log.index>: int .
<Withdrawal.address>: uid @reverse .
<Withdrawal.string>: int .
<Withdrawal.index>: int .
<Withdrawal.validator_index>: int .
<Withdrawal.amount>: int .
type <Account> {
	Account.address
	Account.tags
	Account.is_contract
}
type <Block> {
	Block.number
	Block.datetime
	Block.difficulty
	Block.tx_count
	Block.gas_price_min
	Block.gas_price_max
	Block.gas_price_avg
	Block.gas_price_std_dev
	Block.gas_limit
	Block.gas_used
	Block.base_fee_per_gas
	Block.size
	Block.miner
	Block.withdrawals
}
type <ContractDeployment> {
	ContractDeployment.contract
	ContractDeployment.block
	ContractDeployment.creator
	ContractDeployment.tx_hash
	ContractDeployment.failed_deploy
	ContractDeployment.creation_bytecode
	ContractDeployment.deployed_bytecode
	ContractDeployment.skeleton
	ContractDeployment.storage_protocol
	ContractDeployment.storage_address
	ContractDeployment.experimental
	ContractDeployment.solc_version
	ContractDeployment.verified_source
	ContractDeployment.verified_source_code
	ContractDeployment.name
}
type <ContractDestruction> {
	ContractDestruction.contract
	ContractDestruction.block
	ContractDestruction.tx_hash
	ContractDestruction.balance_left
	ContractDestruction.refound_address
	ContractDestruction.failed
}
type <Error> {
	Error.signature
	Error.name
	Error.inputs
}
type <Event> {
	Event.signature
	Event.name
	Event.inputs
}
type <Function> {
	Function.signature
	Function.name
	Function.inputs
	Function.outputs
}
type <Skeleton> {
	Skeleton.bytecode
	Skeleton.functions
	Skeleton.events
	Skeleton.errors
	Skeleton.failed_decompilation
	Skeleton.erc20_compliancy
	Skeleton.erc721_compliancy
	Skeleton.similar_code
	Skeleton.similar_interface
}
type <TokenTransfer> {
	TokenTransfer.contract
	TokenTransfer.from
	TokenTransfer.to
	TokenTransfer.value
	TokenTransfer.block
	TokenTransfer.tx
	TokenTransfer.token_id
}
type <Transaction> {
	Transaction.hash
	Transaction.from
	Transaction.to
	Transaction.block
	Transaction.value
	Transaction.gas
	Transaction.gas_price
	Transaction.input
	Transaction.bytes4
	Transaction.max_fee_per_gas
	Transaction.max_priority_fee_per_gas
	Transaction.nonce
	Transaction.r
	Transaction.s
	Transaction.v
}
type <Log> {
	Log.contract
	Log.block
	Log.tx
	Log.topic_0
	Log.topic_1
	Log.topic_2
	Log.topic_3
	Log.data
	Log.tx_index
	Log.index
}
type <Withdrawal> {
	Withdrawal.address
	Withdrawal.amount
	Withdrawal.index
	Withdrawal.validator_index
}
\end{lstlisting}

\begin{lstlisting}[
caption={GraphQL schema of indexed data}
]
type Account {
  address: String! @id @search(by: [hash])
  tags: [String] @search(by: [hash])
  is_contract: Boolean @search
  token_sent: [TokenTransfer] @dgraph(pred: "~TokenTransfer.from")
  token_received: [TokenTransfer] @dgraph(pred: "~TokenTransfer.to")
  transactions_sent: [Transaction] @dgraph(pred: "~Transaction.from")
  transactions_received: [Transaction] @dgraph(pred: "~Transaction.to")
  created_contracts: [ContractDeployment] @dgraph(pred: "~ContractDeployment.creator")
  logs: [Log] @dgraph(pred: "~Log.contract")
  deployments: [ContractDeployment] @dgraph(pred:"~ContractDeployment.contract")
  destructions: [ContractDestruction] @dgraph(pred:"~ContractDestruction.contract")
  transfers: [TokenTransfer] @dgraph(pred: "~TokenTransfer.contract")
  mined_blocks: [Block] @dgraph(pred:"~Block.miner")
  withdrawals: [Withdrawal] @dgraph(pred:"~Withdrawal.address")
}

type Withdrawal {
  amount: String! @search
  index: Int
  validator_index: Int
  address: Account! @dgraph(pred:"Withdrawal.address")
  block: [Block] @dgraph(pred:"~Block.withdrawals")
}

type Block {
  number: Int! @id @search
  miner: Account @dgraph(pred:"Block.miner")
  datetime: DateTime @search(by: [hour])
  difficulty: String @search
  tx_count: Int @search
  gas_price_min: Float
  gas_price_max: Float
  gas_price_avg: Float @search
  gas_price_std_dev: Float
  gas_limit: Int
  gas_used: Int
  base_fee_per_gas: Float
  size: Int
  deployments: [ContractDeployment] @dgraph(pred: "~ContractDeployment.block")
  destructions: [ContractDestruction] @dgraph(pred: "~ContractDestruction.block")
  transfers: [TokenTransfer] @dgraph(pred: "~TokenTransfer.block")
  transactions: [Transaction] @dgraph(pred: "~Transaction.block")
  withdrawals: [Withdrawal] @dgraph(pred:"Block.withdrawals")
  logs: [Log] @dgraph(pred: "~Log.block")
}

type Transaction {
  hash: String! @id @search(by: [hash])
  value: String! 
  gas: Int @search
  gas_price: Int @search
  input: String
  bytes4: String @search(by: [hash])
  max_fee_per_gas: Int
  max_priority_fee_per_gas: Int
  nonce: Int
  r: String
  s: String
  v: String
  from: Account! @dgraph(pred:"Transaction.from")
  to: Account! @dgraph(pred:"Transaction.to")
  block: Block! @dgraph(pred:"Transaction.block")
  logs: [Log] @dgraph(pred: "~Log.tx")
}

type Function {
  signature: String! @id @search(by: [hash])
  name: String @search(by: [exact])
  inputs: String @search(by: [trigram])
  outputs: String @search(by: [trigram])
  skeletons: [Skeleton] @dgraph(pred:"~Skeleton.functions")
  bytes4: String @search(by: [hash])
}

type Event {
  signature: String! @id @search(by: [hash])
  name: String @search(by: [exact])
  inputs: String @search(by: [trigram])
  skeletons: [Skeleton] @dgraph(pred:"~Skeleton.events")
}

type Error {
  signature: String! @id @search(by: [hash])
  name: String @search(by: [exact])
  inputs: String @search(by: [trigram])
  skeletons: [Skeleton] @dgraph(pred:"~Skeleton.errors")
}

type ContractDeployment {
  tx_hash: String @search(by: [hash])
  failed_deploy: Boolean @search
  creation_bytecode: String
  deployed_bytecode: String
  storage_protocol: String
  storage_address: String
  experimental: Boolean @search
  solc_version: String @search(by: [hash])
  verified_source: Boolean @search
  verified_source_code: String @search(by: [term])
  name: String @search(by: [trigram])
  contract: Account! @dgraph(pred:"ContractDeployment.contract")
  block: Block! @dgraph(pred:"ContractDeployment.block")
  creator: Account! @dgraph(pred:"ContractDeployment.creator")
  skeleton: Skeleton @dgraph(pred:"ContractDeployment.skeleton")
}

type ContractDestruction {
  tx_hash: String @search(by: [hash])
  balance_left: String
  refound_address: Account! @dgraph(pred:"ContractDestruction.refound_address")
  contract: Account! @dgraph(pred:"ContractDestruction.contract")
  block: Block! @dgraph(pred:"ContractDestruction.block")
}

type Skeleton {
  bytecode: String! @search(by: [hash])
  erc20_compliancy: Int @search
  erc721_compliancy: Int @search
  failed_decompilation: Boolean @search
  deployments: [ContractDeployment] @dgraph(pred:"~ContractDeployment.skeleton")
  functions: [Function] @dgraph(pred:"Skeleton.functions")
  events: [Event] @dgraph(pred:"Skeleton.events")
  errors: [Error] @dgraph(pred:"Skeleton.errors")
  similar_code: [Skeleton]
  similar_interface: [Skeleton]
}

type TokenTransfer {
  value: String!
  token_id: String
  tx: Transaction
  block: Block! @dgraph(pred:"TokenTransfer.block")
  contract: Account! @dgraph(pred:"TokenTransfer.contract")
  from: Account! @dgraph(pred:"TokenTransfer.from")
  to: Account! @dgraph(pred:"TokenTransfer.to")
}

type Log {
  topic_0: String @search(by: [hash])
  topic_1: String @search(by: [hash])
  topic_2: String @search(by: [hash])
  topic_3: String @search(by: [hash])
  data: String 
  tx_index: Int
  index: Int
  contract: Account! @dgraph(pred:"Log.contract")
  block: Block @dgraph(pred:"Log.block")
  tx: Transaction @dgraph(pred:"Log.tx")
}
\end{lstlisting}

\chapter*{C - Data returned from RPCs}
\addcontentsline{toc}{chapter}{\protect\numberline{}C - Data returned from RPCs} 

To give more context here are included three examples of data returned from the RPCs that were used for extracting Ethereum data 


\subsection*{eth\_getBlockByNumber}

\begin{lstlisting}[
caption={Data returned from eth\_getBlockByNumber RPC with hydrated transactions},
label={lst:block-data-rpc}
]
{
    "transactions": [
        ...,
        {
        
        },
        ...
    ]
}
\end{lstlisting}

\subsection*{eth\_getLogs}

\begin{lstlisting}[
caption={Data returned from eth\_getLogs RPC},
label={lst:log-data-rpc}
]
[
    ...,
    {
    
    },
    ...
]
\end{lstlisting}

\subsection*{trace\_block}

\begin{lstlisting}[
caption={Data returned from trace\_block RPC},
label={lst:trace-data-rpc}
]
[
    ...,
    {
    
    },
    ...
]
\end{lstlisting}
